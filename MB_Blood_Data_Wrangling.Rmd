---
title: "Marshbird blood data"
author: "Chauncey Gadek & Jessie Williamson"
date: "9/2/2020"
output:
  pdf_document: default
  html_document: default
---

#### 

This script includes: processing raw data, evaluating and eliminating outliers, creating new variables, reading out of final data file for modeling, plotting, etc.

####

# QUESTIONS 

**1) How do blood parameters vary with abiotic aspects of the environment?** 
Predictors: 
1) elevation 
2) temperature index (PC1 of 19 BioClim variables)
3) aridity index (PC1 of 19 BioClim variables)
4) latitude

**2) How to blood parameters vary with aspects of species biology and compare between species?** 
Predictors: 
5) body mass
6) external morphology (tarsus, culmen, etc...)
7) flight muscle
8) heart mass


**3) What relationships exist among blood parameters?**
6 total: [Hb], Hct, TRBC, MCV, MCH, MCHC


# DATASET 
Dataset includes blood and morphological data for Phelocryptes melanops, Tachuris Rubrigastra, Troglodytes aedon, and Zonotrichia capensis from both coastal and montane Peru and coastal Chile (though we may remove these). Sampling was conducted from 2015-2020 by students, affiliates, researchers, and professors at the Museum of Southwestern Biology at the University of New Mexico. All data are linked to vouchered specimens*. 
*Note: Because some tissues and specimens haven't been exported from Peru, and because Chile collection isn't yet catalogued, not all are archived in Arctos. 

# APPROACH (This is largely canabalized from J Williamson blood script, adjust to fit dataset and questions)
We will build X sets of phylogenetic mixed models in brms (x 10 models per set)

Response variables: 
1) Hb
2) Hct
3) TRBC
4) MCV
5) MCH
6) MCHC
7) PC axes of above variables?
8) Bootstrapped convex hull overlaps of generalist specialist species pairs?

Predictor set for each set of models: 
1) elevation 
2) temperature index
3) precip index
4) latitude 
5) mass
6) intraspecific variation: elevation
7) intraspecific variation: latitude
8) intraspecific variation: mass
9) intraspecific vatiation: precip
10) intraspecific variation: temp 
(+ (1|species))
11) Phylogeny + (1|phylogeny)

For each response, we will include: 
1) Null model (intercept-only)
2) Random effects-only model (intercept + phylogenetic random effect + species random effect)
3) Full model with no random effects (just predictors) 
4) Full model with just phylo random effect
5) Full model with just species random effect 
6) Full model with phylo and species random effects 
7) Reduced model with no random effects (just predictors whose CIs do NOT overlap zero)
8) Reduced model with just phylo random effect 
9) Reduced model with just sepcies random effect 
10) Reduced model with phylogenetic and species random effects 

We'll use LOOIC and WAIC to compare model sets.


```{R, echo=FALSE}
# I set some GLOBAL R chunk options here.
#   (to hide this message add "echo=FALSE" to the code chunk options)
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)

#knitr::opts_chunk$set(cache = TRUE, autodep=TRUE)
knitr::opts_chunk$set(cache = TRUE, autodep=TRUE)
```


# Load packages
```{R}
library(reshape)
library(reshape2)
library(plyr)
library(dplyr)
library(car)
library(GGally)
library(Hmisc)
library(gridExtra)
library(stats)
library(gplots)
library(ggplot2)
library(stats4) # Forces knitr to work when it's being wonky
library(PMCMR) #Allows Kruskal-Wallis post-hocs
library(effects)
library(gridExtra)
library(lattice)
library(survival)
library(fmsb)
library(faraway)
library(ape)

# Mapping 
library(raster)
library(sp)
library(rgdal)
library(RStoolbox)
library(prettymapr)
library(viridis)
library(rasterVis)
library(sdm)
library(CommEcol)


# Modeling packages 
library(nlme)
library(lme4)
library(AICcmodavg)
library(MuMIn)
library(glmulti)
library(lsmeans)
library(rsq) # get r-squared values from GLM
library(r2glmm) # for R^2 values from lmer() and glmer()
library(multcompView) # related to multiple comparisons?
library(jtools) # interaction plots 
library(interactions) # interaction plots 
library(broom)
library(stargazer) # model output tables
library(ggeffects) # for estimating model predictions from mixed effects models
library(brms)
library(MCMCglmm)
library(rstan) #won't install
library(bayesplot)

# Phylo packages 
library(phytools)
```


---
# load in data (marshbirds)
```{R}
# Load functions 
source("/Users/Gadek/Dropbox/Research/Marsh Birds/ada_functions.R") # Erik's ADA functions for clean & collated lm diag plots

# All marsh bird blood data
# now combined into one working master blood file 

# Note: all variables read in with "X0_" (just "0_" in Excel) are variables that will be dropped once you run code for 
# blood calculations below. This prefix indicates DROP ME, NOT PART OF FINAL ANYTHING.

# All marshbird blood data
MB <- read.csv("/Users/Gadek/Dropbox/Research/Marsh Birds/marsh_birds_blood.csv")

#remove weird X columns introduced by excel
MB <-MB[, -(46:109)] #cannot use grep X here because removes columns that I need! pain in the ass!

# make factor variables
blood <-
  MB %>%
  mutate_if(is.character, as.factor) #change all characters to factors

```

# load in data (generalists)
```{R}
EG <- read.csv("/Users/Gadek/Dropbox/Research/Marsh Birds/EG_blood.csv")

# make factor variables
EG <-
  EG %>%
  mutate_if(is.character, as.factor) #change all characters to factors


#check for relationship between mass and elevation
p <- ggplot(EG, aes(elev, mass))+
  geom_point()+
  geom_smooth(method ="lm")+
  facet_wrap(.~species)
p

p <- ggplot(EG, aes(elev, as.numeric(supra)))+
  geom_point()+
  geom_smooth(method ="lm")+
  facet_wrap(.~species)
p

p <- ggplot(EG, aes(elev, as.numeric(tHb)))+
  geom_point()+
  geom_smooth(method ="lm")+
  facet_wrap(.~species)
p
dev.off()
```

#combine marshbirds and generalists
```{R}
blood <- rbind(blood, EG)

#add column designating generalists and specialists
blood$g.or.s <- NA
for (i in 1:nrow(blood)) {
  if(blood$species[i] %in% c("Tachuris rubrigastra", "Phleocryptes melanops")){
    blood$g.or.s[i] <- "s"
  }else{
    blood$g.or.s[i] <- "g"
  }
}

#redo elevcat
blood$elev_cat <- NA
for (i in 1:nrow(blood)) {
  if(blood$elev[i] >= 3000){
    blood$elev_cat[i] <- "h"
  }else if(blood$elev[i] <= 1000){
    blood$elev_cat[i] <- "l"
  }else{
    blood$elev_cat[i] <- "m" #may want to re-calibrate these bins
  }
}
  
```

# Calculate blood metrics and make variables needed for analysis 
```{r}
library(dplyr)

# HEMOGLOBIN - corrected
blood <- blood %>% mutate(hb_corr = (tHb - 1)) # correct all Hb values 
names(blood)[names(blood) == "hb_corr"] <- "hb_final" # Change name for consistent naming

# HEMATOCRIT
blood <- 
  blood %>% mutate(hct1_middle_calculated = (hct1_top + hct1_bottom)/2, # Make Hct middle calculation
                      hct1_ratio = (hct1_middle_calculated/hct1_column), # Hct1 ratio
                      hct2_middle_calculated = (hct2_top + hct2_bottom)/2, # Make Hct 2 middle calculation
                      hct2_ratio = (hct2_middle_calculated/hct2_column), # Hct2 ratio
                      wtavg_hct = (hct1_ratio*(hct1_column/(hct1_column + hct2_column))) + (hct2_ratio*(hct2_column/(hct2_column + hct1_column))), # Weighted average of Hct measurements
                      hct_final = coalesce(hct1_ratio, wtavg_hct), # Take Hct1_ratio when only 1 measurement exists
                      hct_percent = (hct_final*100) # display HCT in percent; necessary for proper format
                      )
# Weighted average of Hct measurements is equivalent to Packed Cell Volume (PCVs %)
# Note that last line is important! In instances where you can't take weighted avg because only 1 Hct measurement, 
# use Hct1_ratio; else use wtavg_hct measurements for calculations 

#TRBC
#change name of  "RBCx10.6mm.3" to TRBC
#names(blood)[names(blood) == "RBCx10.6mm.3"] <- "trbc"
              
# MEAN CELL VOLUME (MCV)
# Formula for MCV (fl) from Campbell & Ellis (2007): (HCT%/TRBC)*10
# This can also be calculated with the following: (hct_final/TRBC)*1000 (note that hct_final isn't in %; it's decimals)
# NOTE: Our data doesn't have the x5, x10000, and x200_dilution variables that my Patagona dataset does becuase no mean 
# MCV cell counts; just finalized RBCx10^6mm^3 counts
#First get TRBC by multiplying number of erythrocytes counted in five cytometer sauqres by 10,000, etc... but need to combine TRBC already calculated in EG dataframe
blood$TRBC <-NA
for (i in 1:nrow(blood)) {
  if(is.na(blood$Hemacytometer_RBC_sum_of_5grids[i])){
    blood$TRBC[i] <- blood$RBCx10.6mm.3[i]
  }else{
    blood$TRBC[i] <- (blood$Hemacytometer_RBC_sum_of_5grids[i]*5*10000*200)/1000000000
  }
}
  
blood <- blood %>% mutate(MCV_calculated = (hct_percent/TRBC*10)) # , # Mean Cell Volume 
names(blood)[names(blood) == "MCV_calculated"] <- "MCV_final" # Change name for use in formula below
hist(blood$MCV_final)

# MCHC (mean cellular hemoglobin concentration)
# Formula for MCHC (gm/dl) from Campbell & ellis (2007): (Hb/HCT %)*100
blood <- blood %>% mutate(MCHC_calculated = (hb_final/hct_percent)*100) # Calculated MCHC
names(blood)[names(blood) == "MCHC_calculated"] <- "MCHC_final" # Change name 


# MCH (mean cell hemoglobin)
# Formula for MCH (pg) from Campbell & ellis (2007): (Hb/TRBC)*10
blood <- blood %>% mutate(MCH_calculated = (hb_final/TRBC*10)) # Calculated MCH
names(blood)[names(blood) == "MCH_calculated"] <- "MCH_final" # Change name

```


# convert lats and lons
```{r}
# Function to convert latitude from degrees decimal minutes to decimal degrees 
convert_lat <- function(dataframe){
  lat_degrees_S <- dataframe$lat_deg 
  lat_mins <- dataframe$lat_min 
  lat <- lat_degrees_S + (lat_mins/60)
  return(-lat) # ask to return negative to indicate southern hemisphere 
}

# Function to convert longitude from degrees decimal minutes to decimal degrees 
convert_lon <- function(dataframe){
  lon_degrees_W <- dataframe$lon_deg
  lon_mins <- dataframe$lon_min
  lon <- lon_degrees_W + (lon_mins/60)
  return(-lon) # ask to return negative to indicate western hemisphere 
}

blood$lat <- convert_lat(blood) # Convert all lat values and add to data frame 
blood$lon <- convert_lon(blood) # Convert all lon values and add to data frame 

# Check positions of lat and lon with simple world map (all should be in southern hemisphere)
library(maptools)
data(wrld_simpl)
plot(wrld_simpl, xlim=c(-100,-30), ylim=c(-57,17), axes=TRUE, col="snow2") # plots gray world map 
box() # restore the box around the map
points(blood$lon, blood$lat, col='cyan3', pch=20, cex=0.5) # plot lat/lon points
# Looks good; all points appear in their proper places 

# Drop the one instance of no lat/lon, which will cause problems for spatial data below
blood <- blood %>% filter(!is.na(lat)) # keep only records with lat 
blood <- blood %>% filter(!is.na(lon)) # keep only records with lon

```

# Predictor scatterplot matrix for blood
Predictors/possible predictors for models for models
```{R, fig.height = 6, fig.width = 6}

# Initial outlier/distribution assessment 

# Hb
hist(blood$hb_final)
abline(v=c(13,25), col=c("red", "red"), lty=c(2,2), lwd=c(2, 3)) # <24 and > 25 outliers 
blood[which(blood$hb_final < 13),] # 27 outliers after lowering threshold to 13; 57 if >14 ALL Z.cap and T.aedon... mixed elevations...
blood[which(blood$hb_final > 25),] # 0 outliers 

# Hct
hist(blood$hct_final)
abline(v=c(0.35,0.75), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <35 and > 75 outliers 
blood[which(blood$hct_final < 0.35),] # 6 outliers 
blood[which(blood$hct_final > 0.75),] # 0 outliers 

# trbc
hist(blood$TRBC)
abline(v=c(2,10), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
blood[which(blood$RBCx10.6mm.3 < 2),] # 0 outliers 
blood[which(blood$RBCx10.6mm.3 > 10),] # 1 outlier

# MCV
hist(blood$MCV_final)
abline(v=c(50,200), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <50 and > 200 outliers 
blood[which(blood$MCV_final < 50),] # 2 outliers 
blood[which(blood$MCV_final > 200),] # 2 outliers
# Note: some crossover in TRBC and MCV outliers

# MCHC
hist(blood$MCHC_final)
abline(v=c(20,42), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <20 and > 42 outliers 
blood[which(blood$MCHC_final < 20),] # 0 outliers 
blood[which(blood$MCHC_final > 42),] # 5 outliers Tachuris (low elev) and Troglodytes (high elev) weird pattern here... maybe something interesting...

# MCH
hist(blood$MCH_final)
abline(v=c(18,200), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <50 and > 200 outliers PROBLEM HERE!!! <50 removes most of dataset... 
blood[which(blood$MCH_final < 18),] # 2 outliers 
blood[which(blood$MCH_final > 200),] # 0 outliers

# Generally, these look really good. I don't think any need to be transformed, but that could change. 
qqPlot(blood$mass) # looks like shit (but after account for species in model I bet it will look solid)
qqPlot(blood$hb_final) # ok 
qqPlot(blood$hct_final) # ok
qqPlot(blood$TRBC) # ok
qqPlot(blood$MCV_final) # Upper limit of 150 MCV brings curvature at tails within liveable/normal-ish range = good ... CHauncey: I'm not convinced I want to remove so many values... May hust transform...
qqPlot(blood$MCHC_final) # off at the right tail, ok
qqPlot(blood$MCH_final) # Still a little off at the tails, but very livable 

hist(blood$mass) #multimodal but expected given species differences
hist(blood$elev)
hist(blood$hb_final) #Left skew apparent
hist(blood$hct_final) #Left skew apparent
hist(blood$MCV_final) 
hist(blood$MCH_final) 
hist(blood$MCHC_final) # major right skew...
```


# Drop outlier values for blood parameters
note: you CANNOT run na.omit on your subsetted data or you'll be left with only X observations. 
I think the best approach is to create separate subsets that remove outliers for each possible response variable of interest; that way, you'll retain as many values as possible in the subsetted dataset
```{r}
# BlOOD DATASET OUTLIERS 
# For [Hb]: drop any value <14 or >25
# DuBay and Witt range from 13.2-21.4 g/dl
blood.final <- blood[-which(blood$hb_final < 13 | blood$hb_final > 25),]  #27 observations AGAIN THIS IS BY ADJUSTNG THB LOWER THRESHOLD MAINLY!!!!!

# for Hct: drop any value <35 or >75
# (we originally had this set to 72 but I bumped it to 75 after examining distribution)
# DuBay and Witt range from 46.3-58.1 for Hct
blood.final <- blood.final[-which(blood.final$hct_final < 0.35 | blood.final$hct_final > 0.75),] #-3 observations
# Campbell and Ellis report "normal" range for birds 35-55
# <35% suggests anemia; >55% suggests dehydration or erythrocytocis (polycythemia; increase in RBCs)
# They note that PCV > 70% is usually indicative of chronic pulmonary disease 

# For TRBC: drop any value <2 or >10
# I read somewhere online that bird 'normal' range is 2.5-4.5, with lower indicating anemia
# Full Campbell and Ellis range from Table B3 is 1.2-4.7
# We expect these values to be higher because of altitude effects
# Based on inspection of the distribution, we pick an informed range of 2-10
#don't need to drop any
#blood <- blood[-which(blood$TRBC < 2 | blood$TRBC > 10),]

# Note: Campbell and Ellis 2007 say: 
# "assessment of abnormal values of MCV, MCH, and MCHC has not been properly evaluted in birds" - so outliers are up to us

# for MCV: drop any value <50 or >200
blood.final <- blood.final[-which(blood.final$MCV_final < 50 | blood.final$MCV_final > 200),] # 3 observations 
# Cambpell & Ellis note that 308 MCV is "large" and indicative of younger cells while 128 is smaller, suggests older cells
# I made the upper limit cut-off 150 instead of 200 after looking at distributions again; makes hist and qqPlots look better. Chauncey: I readjusted to 200 to try and keep as many obs as possible not as worried about slight qq dev... ONLY 1 outlier dropped if less stringant upper threshold of 200 used

# for MCHC: drop any value <20 or >42
# Campbell and Ellis values range from 20-38.5 (Table B3); Dubay & Witt values range from 
# DuBay and Witt range from 26.5-36.9 g/dl
blood.final <- blood.final[-which(blood.final$MCHC_final < 20 | blood.final$MCHC_final > 42),] # -2 observations 
# Leave for now; consider making this a more stringent 22-40

# for MCH: drop any value 
# Elarabany 2018 values for two duck species range from 24.6-31.1 PG; normal range for humans is 32-36 gm/dl OT SURE WHAT TO DROP HERE DISTRIBUTION LOOKS SOLID COULD TRIM TAILS 20-60
blood.final <- blood.final[-which(blood.final$MCH_final < 20 |blood.final$MCH_final > 60),] # 3 observations 

# Total outlier points dropped: 38 of 683
# 645 total data points for analysis

# The plots/distributions above certainly look a LOT better after removing outliers

#write subset for internet mapping
blood.internet <- blood.final%>%
  select(species, sex, bursa, locality, elev, elev_cat, lat, lon, tHbcorr)

blood.internet <- na.omit(blood.internet)
write.csv(blood.internet, file = "blood_final.csv")
```

Note about outlier removal: Since dropping extreme values for e.g. MCV leads to a LOT of lost data, another thing I could do is JUST remove outliers for individual model datasets. I could then check the distributions of individual model data sets before working with them, and this would allow me to ditch 8 weird MCV values but keep the associated perfectly regular hemoglobin values, for example. 

# Assess age-based outliers
Blood data is anomalous in in nestlings and fledglings and normalizes quickly within a few months of fledging. 
Bursa lasts longer than weird juvenile blood characteristics, so presence/absence of bursa isn't 100% correlative with ages that would be important for blood analyses. Me, Chris, and Ethan decided that looking at a combination of characteristics is the best approach: 
- First, eliminate anomalous blood values 
- Then, analyze distribution of blood values. If these look normal and fit in with others, don't remove on the basis of having a bursa. But, if blood values look weird AND a bird has a "large" bursa, then remove value. 
- "Large" bursa is ~2x2 mm or greater for hummingbirds - CCW says this is a bird recently out of the nest.  
- This approach allows us to identify and possibly drop any errant values caused by age and retain all values of juveniles that fall within the "normal" adult range.
# Subset by species
```{R}
blood_t.r <- dplyr::filter(blood.final, species == "Tachuris rubrigastra")
blood_p.m <- dplyr::filter(blood.final, species == "Phleocryptes melanops")
blood_t.a <- dplyr::filter(blood.final, species == "Troglodytes aedon")
blood_z.c <- dplyr::filter(blood.final, species == "Zonotrichia capensis")
```

```{r}
# GGpairs comparison plot colored by age 
p <- ggpairs(blood_p.m[ ,c("elev", "mass", "hb_final", "hct_final", "TRBC", "MCV_final", "MCH_final", "MCHC_final", "bursa")], 
            mapping=ggplot2::aes(colour=as.factor(blood_p.m$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

p <- ggpairs(blood_t.r[ ,c("elev", "mass", "hb_final", "hct_final", "TRBC", "MCV_final", "MCH_final", "MCHC_final", "bursa")], 
            mapping=ggplot2::aes(colour=as.factor(blood_t.r$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

p <- ggpairs(blood_t.a[ ,c("elev", "mass", "hb_final", "hct_final", "TRBC", "MCV_final", "MCH_final", "MCHC_final", "bursa")], 
            mapping=ggplot2::aes(colour=as.factor(blood_t.a$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

p <- ggpairs(blood_z.c[ ,c("elev", "mass", "hb_final", "hct_final", "TRBC", "MCV_final", "MCH_final", "MCHC_final", "bursa")], 
            mapping=ggplot2::aes(colour=as.factor(blood_z.c$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

# pink = adult
# blue = juvenile

# P. melanops looks pretty good. If age-based outliers remained, we'd expect lots of errant green points
# Juvenile MCHC final looks like it is shifted higher relative to adults. MCV juvenile is shifted lower but within range of adults.

#T. rubrigastra has some interesting patterns. Juvenile blood metrics much less sample variance than adults (MCHC, hb, hct) All fall within range of adults. Actually seems like there is one juvenile outlier with high MCHC and MCV MAY BE WORTH REMOVING HIGH ELEV JUVENILE!

#T.aedon Problem here with missing values!!! need to explore this above. Clear juvenile outliers probably remove...

#Z. cap has similar missing values. Need to address this!! Otherwise ge-based outliers don't seem to be an issue.
```

# Standardize Blood Data
```{R}
blood.final <- blood.final %>%
                        mutate(hb_final = scale(hb_final),
                          hct_final = scale(hct_final),
                          TRBC = scale(TRBC),
                          MCV_final = scale(MCV_final),
                          MCHC_final = scale(MCHC_final),
                          MCH_final = scale(MCH_final))

```

# Morphology Only Dataset
```{R}
morpho <- blood.final %>% dplyr::select(NK, species, mass, supra, pect, heart, bursa, lat, lon, elev, elev_cat) #have to use this syntax with dplyr since raster or other package has redundant conflicting name

morpho$supra <-as.numeric(morpho$supra)
morpho$pect <-as.numeric(morpho$pect)
morpho$heart <-as.numeric(morpho$heart)
```

# Subset morphology by species
```{R}
morpho_t.r <- filter(morpho, species == "Tachuris rubrigastra")
morpho_p.m <- filter(morpho, species == "Phleocryptes melanops")
morpho_t.a <- filter(morpho, species == "Troglodytes aedon")
morpho_z.c <- filter(morpho, species == "Zonotrichia capensis")
```


# Predictor scatterplot matrix for morpho
Predictors/possible predictors for models for models
```{R, fig.height = 6, fig.width = 6}
# morpho sub
p <- ggpairs(morpho[ ,c("elev", "mass", "supra", "pect", "heart")], 
            mapping=ggplot2::aes(colour=as.factor(morpho$species)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

# Initial outlier/distribution assessment 
#Tachuris rubrigastra
p <- ggpairs(morpho_t.r[ ,c("elev", "mass", "supra", "pect", "heart")], 
            mapping=ggplot2::aes(colour=as.factor(morpho_t.r$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

# suggests some juvenile values could be influnceing left skew on pectoralis but not too bad.

# mass
hist(morpho_t.r$mass) #mass seems reasonably continous no apparent outliers

# supra
hist(morpho_t.r$supra) #supra looks ok


# pect
hist(morpho_t.r$pect) #huge outlier reomved for p.maj errant entry
abline(v=c(0.2,0.5), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_t.r[which(morpho_t.r$pect< 0.2),] # 2 outliers 
morpho_t.r[which(morpho_t.r$pect > 0.5),] # 1 outliers

#drop em
morpho_t.r <- morpho_t.r[-which(morpho_t.r$pect < 0.2 |morpho_t.r$pect > 0.5 ),] # -3 observations

# heart
hist(morpho_t.r$heart) #mybe a cutoff of 0.13 would be conservative?
abline(v=c(0.05,0.13), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <50 and > 200 outliers 
morpho_t.r[which(morpho_t.r$heart < 0.05),] # 0 outliers 
morpho_t.r[which(morpho_t.r$heart > 0.13),] # 2 outliers 

morpho_t.r <- morpho_t.r[-which(morpho_t.r$heart < 0.05 |morpho_t.r$heart > 0.13 ),] # -2 observations


#Phleocryptes melanops
p <- ggpairs(morpho_p.m[ ,c("elev", "mass", "supra", "pect", "heart")], 
            mapping=ggplot2::aes(colour=as.factor(morpho_p.m$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 


#two outliers with very low p. maj and one with very high supra. Check out!!
# mass
hist(morpho_p.m$mass) #mass seems reasonably continuous no apparent outliers, can consider cutting out birds over 17g?

# supra
hist(morpho_p.m$supra) #one clear outlier at 0.2
abline(v=c(0.02,0.14), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_p.m[which(morpho_p.m$supra< 0.02),] # 0 outliers 
morpho_p.m[which(morpho_p.m$supra > 0.2),] # 1 outliers

#drop em
morpho_p.m <- morpho_p.m[-which(morpho_p.m$supra > 0.2),] # -1 observation

# pect
hist(morpho_p.m$pect) #there are sevral low values perhaps a cutoff of 0.25 or 0.2 would be conservative
abline(v=c(0.2,0.5), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_p.m[which(morpho_p.m$pect< 0.4),] # 1 outlier

#drop em
morpho_p.m <- morpho_p.m[-which(morpho_p.m$pect< 0.4),] # -1 observation

# heart
hist(morpho_p.m$heart) #one outlier below 0.1
abline(v=c(0.12,0.3), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <50 and > 200 outliers 
morpho_p.m[which(morpho_p.m$heart < 0.12),] # 1 outliers 
morpho_p.m[which(morpho_p.m$heart > 0.3),] # 0 outliers 

#drop em
morpho_p.m <- morpho_p.m[-which(morpho_p.m$heart < 0.12),] # -1 observation

#Troglodytes aedon
p <- ggpairs(morpho_t.a[ ,c("elev", "mass", "supra", "pect", "heart")], 
            mapping=ggplot2::aes(colour=as.factor(morpho_t.a$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

# mass
hist(morpho_t.a$mass) #mass seems reasonably continuous no apparent outliers, can consider cutting out birds over 14g? #quite the spread here, but distribution looks good maybe leave?

# supra
hist(morpho_t.a$supra)  #looks great! Leave it.

# pect
hist(morpho_t.a$pect) #one high end outlier...
abline(v=c(0.2,0.8), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_t.a[which(morpho_t.a$pect> 0.9),] # 1 outlier

#drop em
morpho_t.a <- morpho_t.a[-which(morpho_t.a$pect> 0.9),] # -1 observation

# heart
hist(morpho_t.a$heart) #one outlier below 0.1
abline(v=c(0.07,0.2), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <50 and > 200 outliers 
morpho_t.a[which(morpho_t.a$heart < 0.07),] # 2 outliers 
morpho_t.a[which(morpho_t.a$heart > 0.2),] # 1 outlier 

#drop em
morpho_t.a <- morpho_t.a[-which(morpho_t.a$heart < 0.07 | morpho_t.a$heart > 0.2),] # -3 observations

#Zonotrichia capensis
p <- ggpairs(morpho_z.c[ ,c("elev", "mass", "supra", "pect", "heart")], 
            mapping=ggplot2::aes(colour=as.factor(morpho_z.c$bursa)), lower=list(continuous="smooth"), 
            diag = list(continuous = "density")) #, upper = list(params = list(corSize = 6)) )
print(p) 

#clear extreme supra outlier!!

# mass
hist(morpho_z.c$mass) #low mass outlier < 15 remove!!?
abline(v=c(15), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_z.c[which(morpho_z.c$mass <15),] # 1 outlier

#drop em
morpho_z.c <- morpho_z.c[-which(morpho_z.c$mass <15),] # -1 observation

# supra
hist(morpho_z.c$supra)  #looks great after dropping high outlier
abline(v=c(0.4), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_z.c[which(morpho_z.c$supra > 0.4),] # 1 outlier

#drop em
morpho_z.c <- morpho_z.c[-which(morpho_z.c$supra > 0.4),] # -1 observation

# pect
hist(morpho_z.c$pect) #one low end outlier... after removal there is gap in high end but I'm pretty content
abline(v=c(0.2,0.8), col=c("red", "red"), lty=c(2,2), lwd=c(3, 3)) # <2 and > 10 outliers 
morpho_z.c[which(morpho_z.c$pect < 0.8),] # 1 outlier

#drop em
morpho_z.c <- morpho_z.c[-which(morpho_z.c$pect < 0.8),] # -1 observation

# heart
hist(morpho_z.c$heart) #looks great!

#bind trimmed morphosets together.

morpho.final <- rbind(morpho_p.m, morpho_t.a, morpho_t.r, morpho_z.c)
```


#### SPATIAL AND ENVIRONMENTAL DATA ####

# Country polygons, elevation rasters, BioClim download
```{r}
library(raster)
library(sp)

# DOWNLOAD COUNTRY POLYGONS 
# Search country 3-letter ISO code: https://www.iso.org/obp/ui/#search
# Note: Chile's southern coastline makes plotting the outline near impossible; R  crashes every time 
# If you do want to plot outline, write straight to .pdf instead of plotting w/in RStudio
# Best approach seems to be to crop the extent of hte outline to remove Juan Fernandez Islands
# Then to crop and mask climate rasters to Peru and Chile
# THEN to merge these two rasters. 
peru <- raster::getData('GADM', country = "PER", level = 0) # download country shape  
chile <- raster::getData('GADM', country = "CHL", level = 0) 
extent(chile) # look at the spatial extent (lat, lon) of Chile; compare to map 
# Chile's extent goes way out into the Pacific because of Juan Fernandez Islands; get rid of these
extent_mainland <- extent(c(-76, -66.41472, -55.98403,-17.50755)) # Use map to pick a reasonable x min
chile <- crop(chile, extent_mainland) # this takes ~3-5 mins

# Download surrounding countries for visualization/map-making
countries = c("BRA", "ARG", "ECU", "BOL", "VEN", "COL", "GUY", "SUR", "PRY", "URY") 
manycountries = do.call("bind", lapply(countries, function(x) raster::getData('GADM', country=x, level=0)))

# Merge country polygons 
southamerica_countries <- merge(peru, chile, manycountries)

# ELEVATION DATA
# Note similar weirdness with Chile elevation layer as w/ Chile polygons; namely, Juan Fernandez Islands make extent wonky
peru_alt <- raster::getData('alt', country = "PER", mask=TRUE) # Peru elev data
chile_alt <- raster::getData('alt', country = "CHL", mask=TRUE) # Chile elev data; a list of 2
# In Chile alt list: [[1]] = mainland, [[2]] = Juan Fernandez Islands
chile_alt <- chile_alt[[1]] # Assign mainland Chile to to Chile_alt because that's all I want
proj4string(peru_alt) <- CRS("+init=epsg:4326")
proj4string(chile_alt) <- CRS("+init=epsg:4326")
writeRaster(peru_alt, "peru_alt.grd", overwrite=TRUE) # Save raster files
#writeRaster(chile_alt, "chile_alt.grd", overwrite=TRUE)
peru_chile_elev <- merge(peru_alt, chile_alt) # Merge Peru and Chile elev layers for map-making
#writeRaster(peru_chile_elev, "peru_chile_alt.grd", overwrite=TRUE)

# Get elev data for surrounding countries to make your map prettier
bol_alt <- raster::getData('alt', country = "BOL", mask=TRUE) # Bolivia elev data
arg_alt <- raster::getData('alt', country = "ARG", mask=TRUE) # Argentina elev data
bra_alt <- raster::getData('alt', country = "BRA", mask=TRUE) # Brazil elev data
ecu_alt <- raster::getData('alt', country = "ECU", mask=TRUE) # Ecuador elev data
col_alt <- raster::getData('alt', country = "COL", mask=TRUE) # Colombia elev data
vez_alt <- raster::getData('alt', country = "VEN", mask=TRUE) # Venezuela elev data
guy_alt <- raster::getData('alt', country = "GUY", mask=TRUE) # Guyana elev data
sur_alt <- raster::getData('alt', country = "SUR", mask=TRUE) # Suriname elev data
pry_alt <- raster::getData('alt', country = "PRY", mask=TRUE) # Paraguay elev data
uru_alt <- raster::getData('alt', country = "URY", mask=TRUE) # Uruguay elev data
surrounding_elevs <- merge(bol_alt, arg_alt, bra_alt, ecu_alt, col_alt, vez_alt, guy_alt, sur_alt, pry_alt, uru_alt)
# Merge elev layers of surrounding countries
south_america_elevs <- merge(peru_chile_elev, surrounding_elevs) # Merge surrounding countries w/ Chile and Peru
writeRaster(surrounding_elevs, "surrounding_elevs.grd", overwrite=TRUE) # Save raster files
writeRaster(south_america_elevs, "south_america_elevs.grd", overwrite=TRUE)

# GET CLIMATE DATA, CROP TO COUNTRY SHAPES
climate <- raster::getData("worldclim", var="bio", res = 2.5) # download bioclim data
projection(climate) <- CRS("+init=epsg:4326")
chile_clim <- climate %>% crop(., chile) %>% raster::mask(., chile) # Crop and mask climate raster to Chile
peru_clim <- climate %>% crop(., peru) %>% raster::mask(., peru) # Crop and mask climate raster to Peru
proj4string(chile_clim) == proj4string(peru_clim) #check projections between Peru and Chile files 
peru_chile <- merge(peru_clim, chile_clim) # Merge Peru and Chile rasters; this forms raster brick 
plot(peru_clim$bio1) # Plot this as a test that the above cropping and masking worked
# # NOTE: must call raster::mask()! Otherwise mask() is actually masked by another function and I get an error message. 
# # Masking literally masks the shapes of adjoining countries (i.e. "messy stuff") for a clean look; not masking...doesn't.
plot(peru_chile$layer.12) # plot to verify this worked; layer is calling a bioclim variable
proj4string(climate) == proj4string(peru_chile) #check projections
#writeRaster(climate, "world_climate.grd", overwrite=TRUE) # the world?; write out bioclim brick; takes ~10-15 mins
#writeRaster(peru_chile, "peru_chile_bioclim.grd", overwrite=TRUE) # Just Peru and Chile

# Note: I tried to switch Sabrina's order to merge polygons and THEN clip + mask but this never worked
# For some reason it kept only grabbing Peru, which is weird. Here's the code anyways:
# peru_chile <- merge(peru, chile) # Merge country polygons 
#peru_chile_clim <- climate %>% crop(., peru_chile) %>% raster::mask(., peru_chile) # Crop and mask climate to countries 


# READ IN RASTERS TO AVOID RUNNING ALL CODE ABOVE 
# Need to run BioClim data above to ensure that peru_chile is a raster brick otherwise you can't extract BioClim
#peru_chile_bioclim <- raster("./peru_chile_bioclim.grd") # read in peru_chile BioClim data
peru_alt <- raster("./peru_alt.grd") #read elevation raster
chile_alt <- raster("./chile_alt.grd") #read elevation raster
surrounding_elevs <- raster("./surrounding_elevs.grd") # surrounding South American country elevs
south_america_elevs <- raster("./south_america_elevs.grd") # All South American country elevs combined


###### PROCESS SPATIAL DATA 

# Create a spatial data frame that has our community localities
# NAs in the data will create problems; e.g. you won't be able to make spatial data frame 
locality.coords <- SpatialPointsDataFrame(
                   matrix(c(blood$lon, blood$lat), ncol = 2),
                   data.frame(ID=1:nrow(blood),
                   sampling.locality = blood$locality,
                   sampling.elev = blood$elev),
                   proj4string=CRS("+init=epsg:4326")
                   )

# Extract mean temp and mean precip for our all localities 
# Use clipped shape of peru_chile to do this
# If you use peru_clim it won't grab Chile points; if you use chile_clim it won't grab Peru points
# With raster brick, need to specify $layer.1 for $bio1; note this name change or you'll get an error
blood$bio1 <- raster::extract(peru_chile$layer.1, locality.coords)
blood$bio2 <- raster::extract(peru_chile$layer.2, locality.coords)
blood$bio3 <- raster::extract(peru_chile$layer.3, locality.coords)
blood$bio4 <- raster::extract(peru_chile$layer.4, locality.coords)
blood$bio5 <- raster::extract(peru_chile$layer.5, locality.coords)
blood$bio6 <- raster::extract(peru_chile$layer.6, locality.coords)
blood$bio7 <- raster::extract(peru_chile$layer.7, locality.coords)
blood$bio8 <- raster::extract(peru_chile$layer.8, locality.coords)
blood$bio9 <- raster::extract(peru_chile$layer.9, locality.coords)
blood$bio10 <- raster::extract(peru_chile$layer.10, locality.coords)
blood$bio11 <- raster::extract(peru_chile$layer.11, locality.coords)
blood$bio12 <- raster::extract(peru_chile$layer.12, locality.coords)
blood$bio13 <- raster::extract(peru_chile$layer.13, locality.coords)
blood$bio14 <- raster::extract(peru_chile$layer.14, locality.coords)
blood$bio15 <- raster::extract(peru_chile$layer.15, locality.coords)
blood$bio16 <- raster::extract(peru_chile$layer.16, locality.coords)
blood$bio17 <- raster::extract(peru_chile$layer.17, locality.coords)
blood$bio18 <- raster::extract(peru_chile$layer.18, locality.coords)
blood$bio19 <- raster::extract(peru_chile$layer.19, locality.coords)

#This leaves many NAs not sure why... something wrong here
# hypothesis is that since points are so close to significant bodies of water that BIOCLIMs are absent over water? is this TRUE/CRAZY?

clim<-raster(choose.files())
#May Need this function: extracts points within 10 arc minute radius of point
radiusextract<-function(lon,lat,gridshp,radius=0.5){
coor<-coordinates(gridshp)
lonpar<-coor[,1][which(abs(coor[,1]-lon)%in%min(abs(coor[,1]-lon)) )]
latpar<-coor[,2][which(abs(coor[,2]-lat)%in%min(abs(coor[,2]-lat)) )]
data<-data.frame(x=coor[,1], y=coor[,2], val=values(gridshp))
return(select.window(xf=lonpar[1], yf=latpar[1], radius=radius, xydata=data))}

chile.clim1 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.1, radius =0.167 )

#site in chile and one in Ite neeed bioclims pulled from neighboring points
chile.clim1[,3] <- raster::extract(peru_chile$layer.1, chile.clim1[,1:2])
#remove NAs
chile.clim1 <- na.omit(chile.clim1)
#get mean
chile.clim1.mean <- mean(chile.clim1$V3)

ite.clim1 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.1, radius =0.167 )
ite.clim1[,3] <- raster::extract(peru_chile$layer.1, ite.clim1[,1:2])
#remove NAs
ite.clim1 <- na.omit(ite.clim1)
#get mean
ite.clim1.mean <- mean(ite.clim1$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio1[i] <- chile.clim1.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio1[i] <- ite.clim1.mean
  }
}

#Bioclim2
chile.clim2 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.2, radius =0.167 )

chile.clim2[,3] <- raster::extract(peru_chile$layer.2, chile.clim2[,1:2])
#remove NAs
chile.clim2 <- na.omit(chile.clim2)
#get mean
chile.clim2.mean <- mean(chile.clim2$V3)

ite.clim2 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.2, radius =0.167 )
ite.clim2[,3] <- raster::extract(peru_chile$layer.2, ite.clim2[,1:2])
#remove NAs
ite.clim2 <- na.omit(ite.clim2)
#get mean
ite.clim2.mean <- mean(ite.clim2$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio2[i] <- chile.clim2.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio2[i] <- ite.clim2.mean
  }
}

#Bioclim3
chile.clim3 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.3, radius =0.167 )

chile.clim3[,3] <- raster::extract(peru_chile$layer.3, chile.clim3[,1:2])
#remove NAs
chile.clim3 <- na.omit(chile.clim3)
#get mean
chile.clim3.mean <- mean(chile.clim3$V3)

ite.clim3 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.3, radius =0.167 )
ite.clim3[,3] <- raster::extract(peru_chile$layer.3, ite.clim3[,1:2])
#remove NAs
ite.clim3 <- na.omit(ite.clim3)
#get mean
ite.clim3.mean <- mean(ite.clim3$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio3[i] <- chile.clim3.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio3[i] <- ite.clim3.mean
  }
}

#Bioclim4
chile.clim4 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.4, radius =0.167 )

chile.clim4[,3] <- raster::extract(peru_chile$layer.4, chile.clim4[,1:2])
#remove NAs
chile.clim4 <- na.omit(chile.clim4)
#get mean
chile.clim4.mean <- mean(chile.clim4$V3)

ite.clim4 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.4, radius =0.167 )
ite.clim4[,3] <- raster::extract(peru_chile$layer.4, ite.clim4[,1:2])
#remove NAs
ite.clim4 <- na.omit(ite.clim4)
#get mean
ite.clim4.mean <- mean(ite.clim4$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio4[i] <- chile.clim4.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio4[i] <- ite.clim4.mean
  }
}

#Bioclim5
chile.clim5 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.5, radius =0.167 )

chile.clim5[,3] <- raster::extract(peru_chile$layer.5, chile.clim5[,1:2])
#remove NAs
chile.clim5 <- na.omit(chile.clim5)
#get mean
chile.clim5.mean <- mean(chile.clim5$V3)

ite.clim5 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.5, radius =0.167 )
ite.clim5[,3] <- raster::extract(peru_chile$layer.5, ite.clim5[,1:2])
#remove NAs
ite.clim5 <- na.omit(ite.clim5)
#get mean
ite.clim5.mean <- mean(ite.clim5$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio5[i] <- chile.clim5.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio5[i] <- ite.clim5.mean
  }
}

#Bioclim6
chile.clim6 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.6, radius =0.167 )

chile.clim6[,3] <- raster::extract(peru_chile$layer.6, chile.clim6[,1:2])
#remove NAs
chile.clim6 <- na.omit(chile.clim6)
#get mean
chile.clim6.mean <- mean(chile.clim6$V3)

ite.clim6 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.6, radius =0.167 )
ite.clim6[,3] <- raster::extract(peru_chile$layer.6, ite.clim6[,1:2])
#remove NAs
ite.clim6 <- na.omit(ite.clim6)
#get mean
ite.clim6.mean <- mean(ite.clim6$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio6[i] <- chile.clim6.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio6[i] <- ite.clim6.mean
  }
}

#Bioclim7
chile.clim7 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.7, radius =0.167 )

chile.clim7[,3] <- raster::extract(peru_chile$layer.7, chile.clim7[,1:2])
#remove NAs
chile.clim7 <- na.omit(chile.clim7)
#get mean
chile.clim7.mean <- mean(chile.clim7$V3)

ite.clim7 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.7, radius =0.167 )
ite.clim7[,3] <- raster::extract(peru_chile$layer.7, ite.clim7[,1:2])
#remove NAs
ite.clim7 <- na.omit(ite.clim7)
#get mean
ite.clim7.mean <- mean(ite.clim7$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio7[i] <- chile.clim7.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio7[i] <- ite.clim7.mean
  }
}

#Bioclim8
chile.clim8 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.8, radius =0.167 )

chile.clim8[,3] <- raster::extract(peru_chile$layer.8, chile.clim8[,1:2])
#remove NAs
chile.clim8 <- na.omit(chile.clim8)
#get mean
chile.clim8.mean <- mean(chile.clim8$V3)

ite.clim8 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.8, radius =0.167 )
ite.clim8[,3] <- raster::extract(peru_chile$layer.8, ite.clim8[,1:2])
#remove NAs
ite.clim8 <- na.omit(ite.clim8)
#get mean
ite.clim8.mean <- mean(ite.clim8$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio8[i] <- chile.clim8.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio8[i] <- ite.clim8.mean
  }
}

#Bioclim9
chile.clim9 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.9, radius =0.167 )

chile.clim9[,3] <- raster::extract(peru_chile$layer.9, chile.clim9[,1:2])
#remove NAs
chile.clim9 <- na.omit(chile.clim9)
#get mean
chile.clim9.mean <- mean(chile.clim9$V3)

ite.clim9 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.9, radius =0.167 )
ite.clim9[,3] <- raster::extract(peru_chile$layer.9, ite.clim9[,1:2])
#remove NAs
ite.clim9 <- na.omit(ite.clim9)
#get mean
ite.clim9.mean <- mean(ite.clim9$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio9[i] <- chile.clim9.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio9[i] <- ite.clim9.mean
  }
}

#Bioclim10
chile.clim10 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.10, radius =0.167 )

chile.clim10[,3] <- raster::extract(peru_chile$layer.10, chile.clim10[,1:2])
#remove NAs
chile.clim10 <- na.omit(chile.clim10)
#get mean
chile.clim10.mean <- mean(chile.clim10$V3)

ite.clim10 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.10, radius =0.167 )
ite.clim10[,3] <- raster::extract(peru_chile$layer.10, ite.clim10[,1:2])
#remove NAs
ite.clim10 <- na.omit(ite.clim10)
#get mean
ite.clim10.mean <- mean(ite.clim10$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio10[i] <- chile.clim10.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio10[i] <- ite.clim10.mean
  }
}

#Bioclim11
chile.clim11 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.11, radius =0.167 )

chile.clim11[,3] <- raster::extract(peru_chile$layer.11, chile.clim11[,1:2])
#remove NAs
chile.clim11 <- na.omit(chile.clim11)
#get mean
chile.clim11.mean <- mean(chile.clim11$V3)

ite.clim11 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.11, radius =0.167 )
ite.clim11[,3] <- raster::extract(peru_chile$layer.11, ite.clim11[,1:2])
#remove NAs
ite.clim11 <- na.omit(ite.clim11)
#get mean
ite.clim11.mean <- mean(ite.clim11$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio11[i] <- chile.clim11.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio11[i] <- ite.clim11.mean
  }
}

#Bioclim12
chile.clim12 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.12, radius =0.167 )

chile.clim12[,3] <- raster::extract(peru_chile$layer.12, chile.clim12[,1:2])
#remove NAs
chile.clim12 <- na.omit(chile.clim12)
#get mean
chile.clim12.mean <- mean(chile.clim12$V3)

ite.clim12 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.12, radius =0.167 )
ite.clim12[,3] <- raster::extract(peru_chile$layer.12, ite.clim12[,1:2])
#remove NAs
ite.clim12 <- na.omit(ite.clim12)
#get mean
ite.clim12.mean <- mean(ite.clim12$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio12[i] <- chile.clim12.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio12[i] <- ite.clim12.mean
  }
}

#Bioclim13
chile.clim13 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.13, radius =0.167 )

chile.clim13[,3] <- raster::extract(peru_chile$layer.13, chile.clim13[,1:2])
#remove NAs
chile.clim13 <- na.omit(chile.clim13)
#get mean
chile.clim13.mean <- mean(chile.clim13$V3)

ite.clim13 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.13, radius =0.167 )
ite.clim13[,3] <- raster::extract(peru_chile$layer.13, ite.clim13[,1:2])
#remove NAs
ite.clim13 <- na.omit(ite.clim13)
#get mean
ite.clim13.mean <- mean(ite.clim13$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio13[i] <- chile.clim13.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio13[i] <- ite.clim13.mean
  }
}

#Bioclim14
chile.clim14 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.14, radius =0.167 )

chile.clim14[,3] <- raster::extract(peru_chile$layer.14, chile.clim14[,1:2])
#remove NAs
chile.clim14 <- na.omit(chile.clim14)
#get mean
chile.clim14.mean <- mean(chile.clim14$V3)

ite.clim14 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.14, radius =0.167 )
ite.clim14[,3] <- raster::extract(peru_chile$layer.14, ite.clim14[,1:2])
#remove NAs
ite.clim14 <- na.omit(ite.clim14)
#get mean
ite.clim14.mean <- mean(ite.clim14$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio14[i] <- chile.clim14.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio14[i] <- ite.clim14.mean
  }
}

#Bioclim15
chile.clim15 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.15, radius =0.167 )

chile.clim15[,3] <- raster::extract(peru_chile$layer.15, chile.clim15[,1:2])
#remove NAs
chile.clim15 <- na.omit(chile.clim15)
#get mean
chile.clim15.mean <- mean(chile.clim15$V3)

ite.clim15 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.15, radius =0.167 )
ite.clim15[,3] <- raster::extract(peru_chile$layer.15, ite.clim15[,1:2])
#remove NAs
ite.clim15 <- na.omit(ite.clim15)
#get mean
ite.clim15.mean <- mean(ite.clim15$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio15[i] <- chile.clim15.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio15[i] <- ite.clim15.mean
  }
}

#Bioclim16
chile.clim16 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.16, radius =0.167 )

chile.clim16[,3] <- raster::extract(peru_chile$layer.16, chile.clim16[,1:2])
#remove NAs
chile.clim16 <- na.omit(chile.clim16)
#get mean
chile.clim16.mean <- mean(chile.clim16$V3)

ite.clim16 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.16, radius =0.167 )
ite.clim16[,3] <- raster::extract(peru_chile$layer.16, ite.clim16[,1:2])
#remove NAs
ite.clim16 <- na.omit(ite.clim16)
#get mean
ite.clim16.mean <- mean(ite.clim16$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio16[i] <- chile.clim16.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio16[i] <- ite.clim16.mean
  }
}

#Bioclim17
chile.clim17 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.17, radius =0.167 )

chile.clim17[,3] <- raster::extract(peru_chile$layer.17, chile.clim17[,1:2])
#remove NAs
chile.clim17 <- na.omit(chile.clim17)
#get mean
chile.clim17.mean <- mean(chile.clim17$V3)

ite.clim17 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.17, radius =0.167 )
ite.clim17[,3] <- raster::extract(peru_chile$layer.17, ite.clim17[,1:2])
#remove NAs
ite.clim17 <- na.omit(ite.clim17)
#get mean
ite.clim17.mean <- mean(ite.clim17$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio17[i] <- chile.clim17.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio17[i] <- ite.clim17.mean
  }
}

#Bioclim18
chile.clim18 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.18, radius =0.167 )

chile.clim18[,3] <- raster::extract(peru_chile$layer.18, chile.clim18[,1:2])
#remove NAs
chile.clim18 <- na.omit(chile.clim18)
#get mean
chile.clim18.mean <- mean(chile.clim18$V3)

ite.clim18 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.18, radius =0.167 )
ite.clim18[,3] <- raster::extract(peru_chile$layer.18, ite.clim18[,1:2])
#remove NAs
ite.clim18 <- na.omit(ite.clim18)
#get mean
ite.clim18.mean <- mean(ite.clim18$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio18[i] <- chile.clim18.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio18[i] <- ite.clim18.mean
  }
}

#Bioclim19
chile.clim19 <- radiusextract(lon= -71.50817, lat = -32.884933, gridshp =peru_chile$layer.19, radius =0.167 )

chile.clim19[,3] <- raster::extract(peru_chile$layer.19, chile.clim19[,1:2])
#remove NAs
chile.clim19 <- na.omit(chile.clim19)
#get mean
chile.clim19.mean <- mean(chile.clim19$V3)

ite.clim19 <- radiusextract(lon= -70.93837, lat = -17.924717, gridshp =peru_chile$layer.19, radius =0.167 )
ite.clim19[,3] <- raster::extract(peru_chile$layer.19, ite.clim19[,1:2])
#remove NAs
ite.clim19 <- na.omit(ite.clim19)
#get mean
ite.clim19.mean <- mean(ite.clim19$V3)

#Replace NA's
for (i in 1:nrow(blood)) {
  if(blood$locality[i] == "Estero Mantagua"){
    blood$bio19[i] <- chile.clim19.mean
  }
  if(blood$locality[i] == "Patamo de Ite"){
    blood$bio19[i] <- ite.clim19.mean
  }
}

# Now write out this dataset, which represents the near-final version of what you'll want for analysis
#write.csv(final, "MarshbirdsBlood_Wrangled_withBioClim_07-18-20.csv")
```



# Spatial coords PCA 
This is for variable reduction of BioClim variables; look at loadings to understand which directions things work in. 
Collapse temp and aridity variables and use first PCA axis in models. 
NOTE THIS WILL ONLY WORK IF YOU ADJUST COORDINATES (Ite and Estero Mantagua) TO BE ON LAND
```{r}
# Code from Sabrina 
# PCA and scale raster data for temp variables and precip variables

# Temperature PCA using BioClim vars 1-11
tempPCA <- rasterPCA(subset(peru_chile, 1:11), spca = TRUE) #creates a raster of PCAd temp vals
summary(tempPCA$model) #PC1 has 73.4% of variation and 89.5% w/ PC1+PC2
tempPCA$model$loadings #

#Pull PC1 and PC2 values for each community and add to dataset
blood$tempPC1 <- raster::extract(tempPCA$map$PC1, locality.coords)
blood$tempPC2 <- raster::extract(tempPCA$map$PC2, locality.coords)

plot(bio11 ~ tempPC1, data=blood) #PC1 is highly correlated with mean temp
plot(bio11 ~ tempPC2, data=blood) #PC1 also highly correlated w/ mean temp of coldest quarter 
# Fairly correlated w/ bio5, bio6
 
## -------

# Precipitation PCA using BioClim vars 12-19
precipPCA <- rasterPCA(subset(peru_chile, 12:19), spca = TRUE)
summary(precipPCA$model) #PC1 has 79.8% of variation and 89.1% of variation w/ PC1+PC2
precipPCA$model$loadings #

# Add PC1 and PC2 values to dataset 
final$precipPC1 <- raster::extract(precipPCA$map$PC1, locality.coords)
final$precipPC2 <- raster::extract(precipPCA$map$PC2, locality.coords)

plot(bio12 ~ precipPC1, data=final) # Moderate correlation between PC1 and mean annual precip
# Overal not many correlations here 
plot(bio19 ~ tempPC2, data=final) 

# Write out PCA rasters for later map generation:
# writeRaster(tempPCA$map$PC1, "tempPC1.grd", overwrite=TRUE)
# writeRaster(tempPCA$map$PC2, "tempPC2.grd", overwrite=TRUE)
# writeRaster(precipPCA$map$PC1, "precipPC1.grd", overwrite=TRUE)
# writeRaster(precipPCA$map$PC2, "precipPC2.grd", overwrite=TRUE)


# Look at distributions of BioClim variables and transform if necessary 
p <- ggpairs(subset(final, select = c(elev, elev_position, mass, hb, hct, trbc, mcv, mch, mchc, tempPC1, tempPC2, precipPC1, precipPC2))) 
print(p)
# PC variables look a little wonky 

hist(final$tempPC1)
qqPlot(final$tempPC1) # off at tails 

hist(final$tempPC2)
qqPlot(final$tempPC2) # off at left tail  

hist(final$precipPC1)
qqPlot(final$precipPC2) # weird skew 

hist(final$precipPC2)
qqPlot(final$precipPC2) # off at left tail  
```


WORLDCLIM CODEBOOK 
```

They are coded as follows:

BIO1 = Annual Mean Temperature
BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))
BIO3 = Isothermality (BIO2/BIO7) (* 100)
BIO4 = Temperature Seasonality (standard deviation *100)
BIO5 = Max Temperature of Warmest Month
BIO6 = Min Temperature of Coldest Month
BIO7 = Temperature Annual Range (BIO5-BIO6)
BIO8 = Mean Temperature of Wettest Quarter
BIO9 = Mean Temperature of Driest Quarter (*transformed)
BIO10 = Mean Temperature of Warmest Quarter
BIO11 = Mean Temperature of Coldest Quarter
BIO12 = Annual Precipitation
BIO13 = Precipitation of Wettest Month
BIO14 = Precipitation of Driest Month (*transformed)
BIO15 = Precipitation Seasonality (Coefficient of Variation)
BIO16 = Precipitation of Wettest Quarter
BIO17 = Precipitation of Driest Quarter (*transformed)
BIO18 = Precipitation of Warmest Quarter
BIO19 = Precipitation of Coldest Quarter

```


# SAMPLING LOCALITY MAP 
Mapping tips here: https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html
```{r}
library(viridis)
library(RColorBrewer)

# CROP MAP EXTENT FOR BETTER VISUALIZATION 
# Wide version: 
# xmin = -90
# xmax = 41.7
# y min = -45.3
# y max = 0.8

# Zoomed version: 
# xmin = -86
# xmax = 47.4
# y min = -37
# y max = 0.8

# crop raster and country lines to a smaller box (hard to get right, requires a lot of tinkering)
# south_america_elevs_cropped = all elevation rasters combined 
# southamerica_cropped = all country polygons combined 
# These are perfect but fairly zoomed out to capture more of southern Chile 
#ex <- extent(c(-90, -41.7, -45.3, 0.8)) # These go: xmin (left), xmax (right), ymin (bottom), ymax (top)
# Zoomed in version: 
ex <- extent(c(-86, -47.4, -37, 0.8)) # These go: xmin (left), xmax (right), ymin (bottom), ymax (top)
south_america_elevs_cropped <- crop(south_america_elevs, ex)
extent(south_america_elevs_cropped)
southamerica_cropped <- crop(southamerica_countries, ex)

# FINAL MAP
# Peru and Chile sampling localities w/ rest of South America 
pdf("./Peru_and_Chile_SamplingMap_WithSouthAmerica_Cropped_Outlines.pdf", useDingbats = F)
#plot(south_america_elevs_cropped, col = colorRampPalette(c("grey20","grey80"))(100), cex.axis=1.5, ext=ex)
plot(south_america_elevs_cropped, col=magma(200), cex.axis=1.5, ext=ex)
plot(manycountries, add=TRUE, border = "gray92", lwd = 0.05) # outlines surrounding countries; must be first to "layer"
#plot(manycountries, add=TRUE, border = "gray28", lwd = 0.5) # outlines surrounding countries; must be first to "layer"
plot(peru, add=TRUE, border = "white", lwd = 1.5) # This outlines Peru 
plot(chile, add=TRUE, border = "white", lwd = 1.5) # This outlines Peru 
#plot(locality.coords, add=TRUE, pch=19, cex=0.8, col="olivedrab1") # olivedrab1 points w/ no outline # doesn't look great
plot(locality.coords, add=TRUE, pch=21, cex=1.1, bg="olivedrab1") # pch=21 is circle w/ black outline
# olivedrab1 is electric and amazing; olivedrab2 *slightly* subtler and nice, but doesn't 'pop' quite as much
# olivedrab3 looks fantastic; yellow looks nice
addscalebar(plotepsg = 4326, widthhint=0.20, labelpadin = 0.08, label.cex = 0.8, label.col = "black", pos = "bottomleft")
#with(CommunitySpatial, text(CommunitySpatial,
#  labels=CommunitySpatial$ID, pos=4, cex=1.3))
dev.off()

# Played around a lot with aesthetics, namely: w/out country outlines, it's a little hard to orient in South America. 
# EBL thinks 2 colors to denote country lines is a little distracting
# I sorta like thin gray28 spiderweb lines for surrounding countries and thick white lines for Peru and Chile
# I also played around with ALL white outlines but thick for Peru and Chile and super thin for surrounding countries
# I think the best approach might be THICK white Peru + Chile outlines w/ slightly dulled bright gray spiderwebs
# that are much thinner; this makes it look like all the same color, but spiderwebs won't 'pop' as much to distract

# Notes on elevation color palettes, ranked: 
# magma is stunning, sophisticated
# cividis is stunning and lovely; equivalent topography resolution to inferno but subtler palette and nice 
# inferno looks great as well but doesn't pick up as much subtlety in topography as magma 
# Viridis is stunning but is what Sabrina used for Peru malaria paper; magma also picks up more detail in topography
# plasma is ok but looks a little 'cheaper' than magma, which is very sophisticated
# terrain.colors: base R option, looks cheap
# topo.colors: actually painful for the eyes 

# See allhum_blood_comp_CUT.Rmd for other map versions that I cut/didn't include here 
```


# IMPUTE MISSING VALUES? = NO! 
If we don't eliminate NAs or impute missing values, brms won't give proper estimates
```{r}
# Notes on imputation: 
# Don't impute categorical variables
# Dont transform skewed variables: when you transform a variable to meet normality assumptions before imputing, you
    # change the distribution of that variable AND the relationship between that variable and the others you use to impute.
    # Doing so can lead to imputing outliers, creating more bias than just imputing the skewed variable
# The more imputations, the more robust the estimates. Bodner (2008) recommends as many imputations as % missing data.
    # Since our data is 57% complete, I'll run 50 imputations (43% incomplete + buffer)

#library(mice)
#imp <- mice(final, m=5, print=TRUE, maxit=5, method="cart", seed=500) # m= # imputations; maxit= # iterations/datasets
# In order to get this to work, specify method='cart' for 'classification and regression trees'
# High number of unbalanced factors in the data mean default linear regression methods won't work 
# method=cart means 'mice' won't do X matrix inversion and imputation will work 
# mice() returns a list that you can pass directly into brms with:  
# fit_imp1 <- brm_multiple(bmi ~ age*chl, data = imp, chains = 2)

# BUT, AS A GENERAL RULE, DON'T IMPUTE DATA IF YOU HAVE >5% MISSING VALUES!
percent.missing <- function(x){sum(is.na(x))/length(x)*100} # Function to calculate % missing values 
apply(final, 2, percent.missing)
# apply(final.sub, 1, percent.missing)

# We have a lot of missing blood data! % missing data: 
# mass = 1.52%(this would be ok for imputation)
# hb: 13.3% 
# hct 8.88%
# mcv: 38%
# mchc: 21.8%
# mch: 40.4%

# This is really *too* much missing data to be able to impute well. 
# It's clunker, but probably more reliable to create subsets for each blood parameter model set, then remove NAs from those

# SECOND BUT: What we can do is as Chris suggested and impute mass values by taking means across species and sex
# Start with a summary of species means for each sex 
library(dplyr)
species.mass.summary <- final %>% group_by(species, sex) %>%
                                  dplyr::summarize(mean_mass = mean(mass, na.rm = TRUE), 
                                  count =n())
species.mass.summary
# Call summarize from dplyr with dplyr::summarize or R pulls from something else 

# Create a teeny subset with all mass=NA values 
nomasses <- final[-which(!is.na(final$mass)),] # 19 observations missing masses that you'll "impute" w/ species mean values
final.nomasses <- final[-which(is.na(final$mass)),] # Drop missing mass records from final dataset 

# Now, impute missing values manually based on species mean values for each sex 
# There has *got* to be a less manual and clunky as hell way to do this...
colnames(nomasses) # col 15 is mass 
nomasses[nomasses$species=="Aglaiocercus kingii" & nomasses$sex=="female",][15] <- 4.465556 # Mean female mass
nomasses[nomasses$species=="Amazilia chionogaster" & nomasses$sex=="female",][15] <- 5.513333
nomasses[nomasses$species=="Chrysuronia oenone" & nomasses$sex=="male",][15] <- 4.599000
nomasses[nomasses$species=="Coeligena violifer" & nomasses$sex=="male",][15] <- 7.894615
nomasses[nomasses$species=="Coeligena violifer" & nomasses$sex=="female",][15] <- 7.693182
nomasses[nomasses$species=="Colibri coruscans" & nomasses$sex=="male",][15] <- 8.466667
nomasses[nomasses$species=="Eriocnemis luciani" & nomasses$sex=="female",][15] <- 6.491429 
nomasses[nomasses$species=="Eriocnemis luciani" & nomasses$sex=="male",][15] <- 7.133333
nomasses[nomasses$species=="Florisuga mellivora" & nomasses$sex=="male",][15] <- 6.882500
nomasses[nomasses$species=="Metallura tyrianthina" & nomasses$sex=="male",][15] <- 3.784615
nomasses[nomasses$species=="Myrtis fanny" & nomasses$sex=="female",][15] <- 2.648000
nomasses[nomasses$species=="Oreotrochilus melanogaster" & nomasses$sex=="female",][15] <- 7.078448
nomasses[nomasses$species=="Patagona gigas" & nomasses$sex=="female",][15] <- 19.972381
nomasses[nomasses$species=="Pterophanes cyanopterus" & nomasses$sex=="female",][15] <- 10.465714
nomasses[nomasses$species=="Pterophanes cyanopterus" & nomasses$sex=="male",][15] <- 11.550000
nomasses[nomasses$species=="Taphrospilus hypostictus" & nomasses$sex=="female",][15] <- 7.150000

# Recombine datasets 
final <- rbind(final.nomasses, nomasses)

# Check percent missing mass with this, should now be zero 
percent.missing <- function(x){sum(is.na(x))/length(x)*100} # Function to calculate % missing values 
apply(final, 2, percent.missing)

# yay! No missing mass data. 

# Final dataset without Hb genotypes:
write.csv(final, "AllHummingbirdBlood_Wrangled_withBioClim_andPCA_NoHbGenotypes_08-26-20.csv")

```

Vignette on handling missing values w/ brms: 
https://cran.r-project.org/web/packages/brms/vignettes/brms_missings.html

Another imputation tutorial: 
https://stefvanbuuren.name/fimd/sec-toomany.html

More important imputation stuff: 
https://www.theanalysisfactor.com/multiple-imputation-5-recent-findings-that-change-how-to-use-it/

Imputation help: https://www.kaggle.com/c/house-prices-advanced-regression-techniques/discussion/24586

###########



## END 